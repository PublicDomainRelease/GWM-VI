      MODULE GWM1OBJ3
C     VERSION: 27AUG2013
      USE GWM_SUBS, ONLY: IGETUNIT
      USE GWM_STOP, ONLY:   GSTOP
      USE MF2005_UTLS, ONLY: URDCOM, URWORD

      IMPLICIT NONE
      PRIVATE
      PUBLIC::OBJTYP,SOLNTYP,OBJCNST
      PUBLIC::GWM1OBJ3AR,GWM1OBJ3FM,GWM1OBJ3OT,GWM1OBJ3OT2
C
      INTEGER, PARAMETER :: I4B = SELECTED_INT_KIND(9)
      INTEGER, PARAMETER :: I2B = SELECTED_INT_KIND(4)
      INTEGER, PARAMETER :: SP = KIND(1.0)
      INTEGER, PARAMETER :: DP = KIND(1.0D0)
      INTEGER, PARAMETER :: LGT = KIND(.TRUE.)
C
      CHARACTER(LEN=3),SAVE::OBJTYP
      CHARACTER(LEN=4),SAVE::FNTYP
      CHARACTER(LEN=4),SAVE::SOLNTYP
      INTEGER(I4B),SAVE::NFVOBJ,NEVOBJ,NBVOBJ,NSVOBJ
      REAL(DP),SAVE::OBJCNST
      REAL(SP),SAVE,ALLOCATABLE::FVOBJC(:),EVOBJC(:),BVOBJC(:),SVOBJC(:)
C
C      OBJTYP   -direction of optimization: max or min
C      FNTYP    -objective function type 
C      SOLNTYP  -algorithm to be used for solution
C      OBJCNST  -the constant portion of the objective function
C      NFVOBJ   -number of flow-rate variables in objective function
C      NEVOBJ   -number of external variables in objective function
C      NBVOBJ   -number of binary variables in objective function
C      NSVOBJ   -number of state variables in objective function
C      FVOBJC   -objective function coefficient on flow-rate variable
C      EVOBJC   -objective function coefficient on external variable
C      BVOBJC   -objective function coefficient on binary variable
C      SVOBJC   -objective function coefficient on state variable
C
C-----FOR ERROR HANDLING
      INTEGER(I2B)::ISTAT  
      CHARACTER(LEN=200)::FLNM
      CHARACTER(LEN=20)::FILACT,FMTARG,ACCARG 
      INTEGER(I4B)::NDUM
      REAL(SP)::RDUM
C
      CONTAINS
C***********************************************************************
      SUBROUTINE GWM1OBJ3AR(FNAME,IOUT,NPER,PERLEN,NFVAR,NEVAR,NBVAR)
C***********************************************************************
C     VERSION: 11SEPT2009
C     PURPOSE: READ INPUT FROM THE OBJECTIVE-FUNCTION FILE
C-----------------------------------------------------------------------
      USE GWM1BAS3, ONLY : ZERO,CUTCOM
      USE GWM1DCV3, ONLY : FVNAME,EVNAME,BVNAME,FVSP,EVSP
      USE GWM1STA3, ONLY : STANUM,SVNAME,SVSP
      INTEGER(I4B),INTENT(IN)::IOUT,NPER,NFVAR,NEVAR,NBVAR
      REAL(DP),INTENT(IN)::PERLEN(NPER)
      CHARACTER(LEN=200),INTENT(IN)::FNAME
C-----LOCAL VARIABLES
      INTEGER(I4B)::IPRN,I,J,NCAP,NPROW,J1,J2,NCOUNT,ISTART,ISTOP,BYTES
      INTEGER(I4B)::LLOC,INMS,INMF,IKEYS,IKEYF,IFNTS,IFNTF,LOCAT
      REAL(DP)::TTIME
      REAL(SP)::TFVOBJC,TEVOBJC,TBVOBJC,TSVOBJC
      CHARACTER(LEN=10)::TFVNAME,TEVNAME,TBVNAME,TSVNAME
      CHARACTER(LEN=200)::LINE
      LOGICAL(LGT)::NFOUND
      INTEGER(I4B)::NUNOPN,II
C-----ALLOCATE TEMPORARY STORAGE UNTIL SIZE CAN BE DETERMINED
      REAL(SP),ALLOCATABLE::PCW(:)
      CHARACTER(LEN=10),ALLOCATABLE::PNW(:)
      CHARACTER (LEN=1),ALLOCATABLE::CSW(:)
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C1----OPEN FILE
      NUNOPN=IGETUNIT(10,200)
      LOCAT=NUNOPN
      WRITE(IOUT,1000,ERR=990) LOCAT,FNAME
      OPEN(UNIT=LOCAT,FILE=FNAME,ACTION='READ',ERR=999)
C
C-----CHECK FOR COMMENT LINES
      CALL URDCOM(LOCAT,IOUT,LINE)
C
C-----READ IPRN
      LLOC=1
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,IPRN,RDUM,IOUT,LOCAT)
      IF(IPRN.NE.0 .AND. IPRN.NE.1)THEN
        WRITE(IOUT,2000,ERR=990)IPRN
        CALL GSTOP(' ')
      ENDIF
C
C-----READ OBJTYP AND FNTYP AND TEST FOR VALIDITY
      READ(LOCAT,'(A)',ERR=991)LINE
      LLOC=1
      CALL URWORD(LINE,LLOC,IKEYS,IKEYF,1,NDUM,RDUM,IOUT,LOCAT)
      CALL URWORD(LINE,LLOC,IFNTS,IFNTF,1,NDUM,RDUM,IOUT,LOCAT)
      OBJTYP=LINE(IKEYS:IKEYF)
      IF(OBJTYP.NE.'MAX' .AND. OBJTYP.NE.'MIN')THEN
        WRITE(IOUT,3000,ERR=990)                 ! OBJTYP NAME NOT VALID
        CALL GSTOP(' ')
      ENDIF
      FNTYP=LINE(IFNTS:IFNTF)
      IF(FNTYP.NE.'WSDV'.AND.FNTYP.NE.'USDV'.AND.FNTYP.NE.'MSDV')THEN
        WRITE(IOUT,4000,ERR=990)                 ! FNTYP NAME NOT VALID
        CALL GSTOP(' ')
      ENDIF
      WRITE(IOUT,5000,ERR=990)OBJTYP,FNTYP
C
C-----READ NFVOBJ, NEVOBJ, NBVOBJ AND NSVOBJ AND TEST FOR VALIDITY
      READ(LOCAT,'(A)',ERR=991)LINE
      CALL CUTCOM(LINE,200)                      ! REMOVE COMMENTS FROM LINE
      LLOC=1
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,NFVOBJ,RDUM,IOUT,LOCAT)
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,NEVOBJ,RDUM,IOUT,LOCAT)
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,NBVOBJ,RDUM,IOUT,LOCAT)
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,NSVOBJ,RDUM,IOUT,LOCAT)
      IF(NFVOBJ.GT.NFVAR)THEN
        WRITE(IOUT,6000,ERR=990)                 ! VALUE OF NFVOBJ IS INVALID
        CALL GSTOP(' ')
      ENDIF
      IF(NEVOBJ.GT.NEVAR)THEN
        WRITE(IOUT,6010,ERR=990)                 ! VALUE OF NEVOBJ IS INVALID
        CALL GSTOP(' ') 
      ENDIF
      IF(NBVOBJ.GT.NBVAR)THEN
        WRITE(IOUT,6020,ERR=990)                 ! VALUE OF NBVOBJ IS INVALID
        CALL GSTOP(' ')
      ENDIF
      IF(NSVOBJ.GT.STANUM)THEN
        WRITE(IOUT,6025,ERR=990)             ! VALUE OF NSVOBJ IS INVALID
        CALL GSTOP(' ')
      ENDIF
      WRITE(IOUT,6030,ERR=990)NFVOBJ,NEVOBJ,NBVOBJ,NSVOBJ
C
C-----ALLOCATE LOCAL ARRAYS FOR OUTPUT
      ALLOCATE(FVOBJC(NFVAR),EVOBJC(NEVAR),BVOBJC(NBVAR),SVOBJC(STANUM),
     &          PNW(NFVAR+NEVAR+NBVAR+STANUM),
     &          CSW(NFVAR+NEVAR+NBVAR+STANUM),
     &          PCW(NFVAR+NEVAR+NBVAR+STANUM),STAT=ISTAT)
      IF(ISTAT.NE.0)GOTO 992 
      BYTES = 4*(NFVAR+NEVAR+NBVAR+STANUM)
C
C----INITIALIZE COSTS AT 0.0
      FVOBJC=0.0
      EVOBJC=0.0
      BVOBJC=0.0
      SVOBJC=0.0
C
C-----READ COSTS FOR NONZERO FLOW DECISION VARIABLES
      DO 100 I=1,NFVOBJ
        READ(LOCAT,'(A)',ERR=991)LINE
        LLOC=1
        CALL URWORD(LINE,LLOC,INMS,INMF,0,NDUM,RDUM,IOUT,LOCAT)
        CALL URWORD(LINE,LLOC,ISTART,ISTOP,3,NDUM,TFVOBJC,IOUT,LOCAT)
C
C-------CHECK THAT DECISION-VARIABLE NAME HASN'T ALREADY BEEN USED
        TFVNAME=LINE(INMS:INMF)                    ! ASSIGN NAME TO LOCAL VARIABLE
        DO 110 II=1,I-1
          IF(PNW(II).EQ.TFVNAME)THEN
            WRITE(IOUT,7000,ERR=990)TFVNAME        ! NAME HAS BEEN USED 
            CALL GSTOP(' ')
          ENDIF
  110   ENDDO
C
C-------CHECK THAT NAME OF DECISION VARIABLE IS VALID AND SET COSTS
        NFOUND=.TRUE.
        DO 120 J=1,NFVAR
          IF(FVNAME(J).EQ.TFVNAME)THEN
            FVOBJC(J)=TFVOBJC 
            PNW(I)=TFVNAME                       ! SAVE NAME FOR COMPARISON
            PCW(I)=TFVOBJC                       ! SAVE COST FOR OUTPUT
            IF(REAL(TFVOBJC,DP).LT.ZERO)THEN     ! SAVE SIGN FOR OUTPUT
              CSW(I)=CHAR(45)
            ELSE
              CSW(I)=CHAR(43)
            ENDIF
            NFOUND=.FALSE.
            EXIT
          ENDIF
  120   ENDDO
        IF(NFOUND)THEN
          WRITE(IOUT,7100,ERR=990)TFVNAME        ! NAME IS NOT VALID
          CALL GSTOP(' ')
        ENDIF
  100 ENDDO
C
C-------MULTIPLY COSTS BY DURATION OF STRESS PERIODS
      IF(FNTYP.EQ.'WSDV'.OR.FNTYP.NE.'MSDV')THEN
        DO 200 I=1,NFVAR
          TTIME = ZERO                           ! TTIME IS TOTAL DURATION
          DO 210  J=1,NPER                         
            IF(FVSP(I,J)) TTIME = TTIME + PERLEN(J)! SUM STRESS PERIOD DURATIONS
  210     ENDDO
          FVOBJC(I) = FVOBJC(I) * TTIME ! ADJUST COSTS
  200   ENDDO
      ENDIF
C
C-----READ COSTS FOR NONZERO EXTERNAL VARIABLES
      DO 300 I=1,NEVOBJ
        NCOUNT = NFVOBJ + I
        READ(LOCAT,'(A)',ERR=991)LINE
        LLOC=1
        CALL URWORD(LINE,LLOC,INMS,INMF,0,NDUM,RDUM,IOUT,LOCAT)
        CALL URWORD(LINE,LLOC,ISTART,ISTOP,3,NDUM,TEVOBJC,IOUT,LOCAT)
C
C-------CHECK THAT DECISION-VARIABLE NAME HASN'T ALREADY BEEN USED
        TEVNAME=LINE(INMS:INMF)                  ! ASSIGN NAME TO LOCAL VARIABLE
        DO 310 II=NFVOBJ+1,NCOUNT-1
          IF(PNW(II).EQ.TEVNAME)THEN
            WRITE(IOUT,7200,ERR=990)TEVNAME      ! NAME HAS BEEN USED 
            CALL GSTOP(' ')
          ENDIF
  310   ENDDO
C
C----CHECK THAT NAME OF DECISION VARIABLE IS VALID AND SET COSTS
        NFOUND=.TRUE.
        DO 320 J=1,NEVAR
          IF(EVNAME(J).EQ.TEVNAME)THEN
            EVOBJC(J)=TEVOBJC 
            PNW(NCOUNT)=TEVNAME                  ! SAVE NAME FOR COMPARISON
            PCW(NCOUNT)=TEVOBJC                  ! SAVE COST FOR OUTPUT
            IF(REAL(TEVOBJC,DP).LT.ZERO)THEN     ! SAVE SIGN FOR OUTPUT
              CSW(NCOUNT)=CHAR(45)
            ELSE
              CSW(NCOUNT)=CHAR(43)
            ENDIF
            NFOUND=.FALSE.
            EXIT
          ENDIF
  320   ENDDO
        IF(NFOUND)THEN
          WRITE(IOUT,7210,ERR=990)TEVNAME        ! NAME IS NOT VALID
          CALL GSTOP(' ')
        ENDIF
  300 ENDDO
C
C-------MULTIPLY COSTS BY DURATION OF STRESS PERIODS
      IF(FNTYP.EQ.'WSDV')THEN
        DO 360 I=1,NEVAR
          TTIME = ZERO                           ! TTIME IS TOTAL DURATION
          DO 340  J=1,NPER                         
            IF(EVSP(I,J)) TTIME = TTIME + PERLEN(J)! SUM STRESS PERIOD DURATIONS
  340     ENDDO
          EVOBJC(I) = EVOBJC(I) * TTIME ! ADJUST COSTS
  360   ENDDO
      ENDIF
C
C-----READ COSTS FOR NONZERO BINARY VARIABLES
      DO 400 I=1,NBVOBJ
        NCOUNT = NFVOBJ+NEVOBJ+I
        READ(LOCAT,'(A)',ERR=991)LINE
        LLOC=1
        CALL URWORD(LINE,LLOC,INMS,INMF,0,NDUM,RDUM,IOUT,LOCAT)
        CALL URWORD(LINE,LLOC,ISTART,ISTOP,3,NDUM,TBVOBJC,IOUT,LOCAT)
C
C-------CHECK THAT DECISION-VARIABLE NAME HASN'T ALREADY BEEN USED
        TBVNAME=LINE(INMS:INMF)                  ! ASSIGN NAME TO LOCAL VARIABLE
        DO 410 II=NFVOBJ+NEVOBJ+1,NCOUNT-1
          IF(PNW(II).EQ.TBVNAME)THEN
            WRITE(IOUT,7300,ERR=990)TBVNAME      ! NAME HAS BEEN USED 
            CALL GSTOP(' ')
          ENDIF
  410   ENDDO
C
C-------CHECK THAT NAME OF DECISION VARIABLE IS VALID AND SET COSTS
        NFOUND=.TRUE.
        DO 420 J=1,NBVAR
          IF(BVNAME(J).EQ.TBVNAME)THEN
            BVOBJC(J)=TBVOBJC
            PCW(NCOUNT)=TBVOBJC                  ! SAVE COST FOR OUTPUT
            PNW(NCOUNT)=TBVNAME                  ! SAVE NAME FOR COMPARISON
            IF(REAL(TBVOBJC,DP).LT.ZERO)THEN     ! SAVE SIGN FOR OUTPUT
              CSW(NCOUNT)=CHAR(45)
            ELSE
              CSW(NCOUNT)=CHAR(43)
            ENDIF
            NFOUND=.FALSE.
            EXIT
          ENDIF
  420   ENDDO
        IF(NFOUND)THEN
          WRITE(IOUT,7400,ERR=990)TBVNAME        ! NAME IS NOT VALID
          CALL GSTOP(' ')
        ENDIF
  400 ENDDO

C
C-----READ COSTS FOR NONZERO STATE VARIABLES
      DO 500 I=1,NSVOBJ
        NCOUNT = NFVOBJ+NEVOBJ+NBVAR+I
        READ(LOCAT,'(A)',ERR=991)LINE
        LLOC=1
        CALL URWORD(LINE,LLOC,INMS,INMF,0,NDUM,RDUM,IOUT,LOCAT)
        CALL URWORD(LINE,LLOC,ISTART,ISTOP,3,NDUM,TSVOBJC,IOUT,LOCAT)
C
C-------CHECK THAT STATE VARIABLE NAME HASN'T ALREADY BEEN USED
        TSVNAME=LINE(INMS:INMF)                 ! ASSIGN NAME TO LOCAL VARIABLE
        DO 510 II=NFVOBJ+NEVOBJ+NBVAR+1,NCOUNT-1
          IF(PNW(II).EQ.TSVNAME)THEN
            WRITE(IOUT,7410,ERR=990)TSVNAME        ! NAME HAS BEEN USED 
            CALL GSTOP(' ')
          ENDIF
  510   ENDDO
C
C-------CHECK THAT NAME OF STATE VARIABLE IS VALID AND SET COSTS
        NFOUND=.TRUE.
        DO 520 J=1,STANUM
          IF(SVNAME(J).EQ.TSVNAME)THEN
            SVOBJC(J)=TSVOBJC 
            PNW(NCOUNT)=TSVNAME                       ! SAVE NAME FOR COMPARISON
            PCW(NCOUNT)=TSVOBJC                       ! SAVE COST FOR OUTPUT
            IF(REAL(TSVOBJC,DP).LT.ZERO)THEN     ! SAVE SIGN FOR OUTPUT
              CSW(NCOUNT)=CHAR(45)
            ELSE
              CSW(NCOUNT)=CHAR(43)
            ENDIF
            NFOUND=.FALSE.
            EXIT
          ENDIF
  520   ENDDO
        IF(NFOUND)THEN
          WRITE(IOUT,7420,ERR=990)TSVNAME        ! NAME IS NOT VALID
          CALL GSTOP(' ')
        ENDIF
  500 ENDDO
C
C-------MULTIPLY COSTS BY DURATION OF STRESS PERIODS
      IF(FNTYP.EQ.'WSDV')THEN
        DO 600 I=1,STANUM
          TTIME = ZERO                             ! TTIME IS TOTAL DURATION
          DO 610  J=1,NPER  
            IF(SVSP(I,1).EQ.J) TTIME = TTIME + PERLEN(J)! SUM STRESS PERIOD DURATIONS
  610     ENDDO
          SVOBJC(I) = SVOBJC(I) * TTIME   ! ADJUST COSTS
  600   ENDDO
      ENDIF
C
C-----WRITE THE OBJECTIVE FUNCTION TO OUTPUT FILE
      IF(IPRN.EQ.1)THEN
        NCOUNT = NFVOBJ+NEVOBJ+NBVOBJ+NSVOBJ
        WRITE(IOUT,7500,ERR=990)
        NCAP=3                        ! NUMBER OF VALUES PRINTED ON ONE LINE
        NPROW=(NCOUNT-1)/NCAP + 1     ! NUMBER OF ROWS OF THE OBJECTIVE FUNCTION 
        J1=1-NCAP
        J2=0
        DO 810 I=1,NPROW              ! LOOP THROUGH PRINTING ROWS
          J1=J1+NCAP
          J2=J2+NCAP
          IF(J2.GT.NCOUNT)J2=NCOUNT
          IF(I.EQ.1)THEN
            WRITE(IOUT,7510,ERR=990)OBJTYP,(CSW(J),ABS(PCW(J)),PNW(J),
     1        J=J1,J2)
          ELSE
            WRITE(IOUT,7520,ERR=990)(CSW(J),ABS(PCW(J)),PNW(J),J=J1,J2)
          ENDIF
  810   ENDDO
      ENDIF
C
C-----DEALLOCATE LOCAL ARRAYS USED FOR OUTPUT
      DEALLOCATE (CSW,PCW,PNW,STAT=ISTAT)
      IF(ISTAT.NE.0)GOTO 993
C
C-----CLOSE FILE
      CLOSE(UNIT=LOCAT)
      WRITE(IOUT,8000,ERR=990)BYTES
      WRITE(IOUT,8010,ERR=990)
C
 1000 FORMAT(1X,/1X,'OPENING OBJECTIVE-FUNCTION FILE ON UNIT ',I4,':',
     1  /1X,A200)
 2000 FORMAT(1X,/1X,'PROGRAM STOPPED. IPRN MUST BE EQUAL TO 0 OR 1: ',
     1  I4)
 3000 FORMAT(1X,/1X,'PROGRAM STOPPED. OBJECTIVE FUNCTION MUST BE',
     1  ' EITHER MAX OR MIN.')
 4000 FORMAT(1X,/1X,'PROGRAM STOPPED. OBJECTIVE FUNCTION TYPE MUST',
     1  ' BE WSDV, USDV OR MSDV.')
 5000 FORMAT(1X,/1X,'OBJECTIVE TYPE: ',A3,'   FUNCTION TYPE: ',A4)
 6000 FORMAT(1X,/1X,'PROGRAM STOPPED. NFVOBJ MUST BE LESS THAN OR',
     1  ' EQUAL TO NFVAR.')
 6010 FORMAT(/1X,'PROGRAM STOPPED. NEVOBJ MUST BE LESS THAN OR',
     1  ' EQUAL TO NEVAR.')
 6020 FORMAT(1X,/1X,'PROGRAM STOPPED. NBVOBJ MUST BE LESS THAN OR',
     1  ' EQUAL TO NBVAR.')
 6025 FORMAT(1X,/1X,'PROGRAM STOPPED. NSVOBJ MUST BE LESS THAN OR',
     1  ' EQUAL TO NUMBER OF STATE VARS.')
 6030 FORMAT(1X,/1X,'NO. OF FLOW-RATE DECISION VARIABLES IN',
     1  ' OBJECTIVE FUNCTION (NFVOBJ):',T69,I5,/,' NO. OF EXTERNAL',
     2  ' DECISION VARIABLES IN OBJECTIVE FUNCTION (NEVOBJ):',T69,I5,
     3  /,' NO. OF BINARY DECISION VARIABLES IN OBJECTIVE',
     4  ' FUNCTION (NBVOBJ):',T69,I5,
     5  /,' NO. OF STATE VARIABLES IN OBJECTIVE',
     6  ' FUNCTION (NSVOBJ):',T69,I5)
 7000 FORMAT(/1X,'PROGRAM STOPPED. COEFFICIENT FOR DECISION VARIABLE',
     1  A10,/,' HAS ALREADY BEEN SPECIFIED IN OBJECTIVE FUNCTION.') 
 7100 FORMAT(1X,/1X,'PROGRAM STOPPED. ',A10,' WAS NOT DEFINED AS A', 
     1  ' VARIABLE NAME (FVNAME)',/,' IN THE DECISION-VARIABLE FILE.')
 7200 FORMAT(/1X,'PROGRAM STOPPED. COEFFICIENT FOR EXTERNAL VARIABLE',
     1  A10,/,' HAS ALREADY BEEN SPECIFIED IN OBJECTIVE FUNCTION.')
 7210 FORMAT(1X,/1X,'PROGRAM STOPPED. ',A,' WAS NOT DEFINED AS AN',
     1  ' EXTERNAL-VARIABLE NAME (EVNAME)',/,' IN THE DECISION-VARIABLE',
     2  ' FILE.')
 7300 FORMAT(/1X,'PROGRAM STOPPED. COEFFICIENT FOR BINARY VARIABLE',
     1  A10,/,' HAS ALREADY BEEN SPECIFIED IN OBJECTIVE FUNCTION.') 
 7400 FORMAT(1X,/1X,'PROGRAM STOPPED. ',A,' WAS NOT DEFINED AS A',
     1  ' BINARY-VARIABLE NAME (BVNAME)',/,' IN THE DECISION-VARIABLE',
     2  ' FILE.')
 7410 FORMAT(/1X,'PROGRAM STOPPED. COEFFICIENT FOR STATE VARIABLE',
     1  A10,/,' HAS ALREADY BEEN SPECIFIED IN OBJECTIVE FUNCTION.') 
 7420 FORMAT(1X,/1X,'PROGRAM STOPPED. ',A,' WAS NOT DEFINED AS A',
     1  ' STATE-VARIABLE NAME (SVNAME)',/,' IN THE STATE-VARIABLE',
     2  ' FILE.')
 7500 FORMAT(/1X,'OBJECTIVE FUNCTION: (excluding flow duration terms)'
     1   ,/)
 7510 FORMAT(1X,A3,3X,3(1X,A1,ES10.2,1X,A10))
 7520 FORMAT(7X,3(1X,A1,ES10.2,1X,A10))
 8000 FORMAT(/,1X,I8,' BYTES OF MEMORY ALLOCATED TO STORE DATA FOR',
     1               ' OBJECTIVE-FUNCTION')
 8010 FORMAT(/,1X,'CLOSING OBJECTIVE-FUNCTION FILE',/)
C
      RETURN
C
C-----ERROR HANDLING
  990 CONTINUE
C-----FILE-WRITING ERROR
      INQUIRE(IOUT,NAME=FLNM,FORM=FMTARG,ACCESS=ACCARG,ACTION=FILACT)
      WRITE(*,9900)TRIM(FLNM),IOUT,FMTARG,ACCARG,FILACT
 9900 FORMAT(/,1X,'*** ERROR WRITING FILE "',A,'" ON UNIT ',I5,/,
     &7X,'SPECIFIED FILE FORMAT: ',A,/
     &7X,'SPECIFIED FILE ACCESS: ',A,/
     &7X,'SPECIFIED FILE ACTION: ',A,/
     &2X,'-- STOP EXECUTION (GWM1OBJ3AR)')
      CALL GSTOP(' ')
C
  991 CONTINUE
C-----FILE-READING ERROR
      INQUIRE(LOCAT,NAME=FLNM,FORM=FMTARG,ACCESS=ACCARG,ACTION=FILACT)
      WRITE(*,9910)TRIM(FLNM),LOCAT,FMTARG,ACCARG,FILACT
      WRITE(IOUT,9910)TRIM(FLNM),LOCAT,FMTARG,ACCARG,FILACT
 9910 FORMAT(/,1X,'*** ERROR READING FILE "',A,'" ON UNIT ',I5,/,
     &7X,'SPECIFIED FILE FORMAT: ',A,/
     &7X,'SPECIFIED FILE ACCESS: ',A,/
     &7X,'SPECIFIED FILE ACTION: ',A,/
     &2X,'-- STOP EXECUTION (GWM1OBJ3AR)')
      CALL GSTOP(' ')
C
  992 CONTINUE
C-----ARRAY-ALLOCATING ERROR
      WRITE(*,9920)
 9920 FORMAT(/,1X,'*** ERROR ALLOCATING ARRAY(S)',
     &2X,'-- STOP EXECUTION (GWM1OBJ3AR)')
      CALL GSTOP(' ')
C
  993 CONTINUE
C-----ARRAY-DEALLOCATING ERROR
      WRITE(*,9930)
      WRITE(IOUT,9930)
 9930 FORMAT(/,1X,'*** ERROR DEALLOCATING ARRAY(S)',
     &2X,'-- STOP EXECUTION (GWM1OBJ3AR)')
      CALL GSTOP(' ')
C
  999 CONTINUE
C-----FILE-OPENING ERROR
      INQUIRE(LOCAT,NAME=FLNM,FORM=FMTARG,ACCESS=ACCARG,ACTION=FILACT)
      WRITE(*,9990)TRIM(FLNM),LOCAT,'OLD',FMTARG,ACCARG,FILACT
      WRITE(IOUT,9990)TRIM(FLNM),LOCAT,'OLD',FMTARG,ACCARG,
     &                 FILACT
 9990 FORMAT(/,1X,'*** ERROR OPENING FILE "',A,'" ON UNIT ',I5,/,
     &7X,'SPECIFIED FILE STATUS: ',A,/
     &7X,'SPECIFIED FILE FORMAT: ',A,/
     &7X,'SPECIFIED FILE ACCESS: ',A,/
     &7X,'SPECIFIED FILE ACTION: ',A,/
     &2X,'-- STOP EXECUTION (GWM1OBJ3AR)')
      CALL GSTOP(' ')
C
      END SUBROUTINE GWM1OBJ3AR
C
C
C***********************************************************************
      SUBROUTINE GWM1OBJ3FM
C***********************************************************************
C     VERSION: 02JAN2010
C     PURPOSE: LOAD OBJECTIVE COEFFICIENTS INTO THE COST VECTOR
C-----------------------------------------------------------------------
      USE GWM1BAS3, ONLY : ZERO
      USE GWM1DCV3, ONLY : NFVAR,NEVAR,NBVAR,FVNAME,EVNAME,BVNAME,FVDIR
      USE GWM1RMS3, ONLY : CST
      USE GWM1STA3, ONLY : STATERES,STANUM,STARHS
      INTEGER(I4B)::I,ICST
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
      OBJCNST = ZERO                           ! SET CONSTANT PART OF OBJ
C-----COST COEFFICIENTS INTO CST
      DO 100 I=1,NFVAR
        CST(I) =  REAL(FVOBJC(I),DP)           ! LOAD FLOW VARIABLE COSTS
  100 ENDDO
      ICST = NFVAR
      DO 110 I=1,NEVAR
        CST(ICST+I) = REAL(EVOBJC(I),DP)       ! LOAD EXTERNAL VARIABLE COSTS
  110 ENDDO
      ICST = NFVAR+NEVAR
      DO 120 I=1,NBVAR
        CST(ICST+I) = REAL(BVOBJC(I),DP)       ! LOAD BINARY VARIABLE COSTS
  120 ENDDO
C
C-----ADD THE STATE RESPONSE MATRIX COEFFICIENTS TO THE FLOW VARIABLE 
C       COST COEFFICIENTS IN THE OBJECTIVE FUNCTION
      DO 210 I=1,STANUM
        DO 200 ICST=1,NFVAR 
          IF(FVDIR(ICST).EQ.1)THEN             ! INJECTION
            CST(ICST)=CST(ICST)+STATERES(I,ICST)*SVOBJC(I)
          ELSE                                 ! EXTRACTION
C-----------STATERES STORED ASSUMING NEGATIVE WITHDRAWAL VALUES
C             SWITCH SIGN TO ACCOUNT FOR POSITIVE WITHDRAWAL VARIABLES
	      CST(ICST)=CST(ICST)-STATERES(I,ICST)*SVOBJC(I) 
	    ENDIF
  200   ENDDO       
        OBJCNST = OBJCNST-STARHS(I)*SVOBJC(I)   ! ADD UP CONSTANT PART
  210 ENDDO
C
C-----SWITCH SIGN OF OBJ IF MAXIMIZATION
      IF(OBJTYP.EQ.'MAX')THEN                ! CONVERT TO MINIMIZATION
         CST = -CST
	ENDIF
C
      RETURN
      END SUBROUTINE GWM1OBJ3FM
C
C
C***********************************************************************
      SUBROUTINE GWM1OBJ3OT
C***********************************************************************
C     VERSION: 11SEPT2009
C     PURPOSE: WRITE OUTPUT FOR OBJECTIVE FUNCTION
C-----------------------------------------------------------------------
      USE GWM1BAS3, ONLY : ZERO,GWMOUT
      USE GWM1DCV3, ONLY : NFVAR,NEVAR,NBVAR,EVDIR,
     1                     FVNAME,FVDIR,EVNAME,BVNAME
      USE GWM1RMS3, ONLY : CST,RANGENAME,RANGENAMEF
      USE GWM1STA3, ONLY : STANUM,STATERES,SVNAME,STARHS
      INTEGER(I4B)::I,ICST
      REAL(DP)::SUMI,SUME,SUMC,SUMCT,OBJC,OBJS,WCST
      CHARACTER(LEN=10)::ETYPED(7)
      DATA ETYPED /'  Import  ','  Export  ','  Head    ',
     &    '  Strmflow','  Storage ','  General ','  Drain   '/
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C-----WRITE OPTIMAL FLOW VARIABLES
      SUMI = ZERO
      SUME = ZERO
      SUMC = ZERO
      SUMCT= ZERO
      WRITE(GWMOUT,2000,ERR=990)
      DO 100 I=1,NFVAR
        IF(FVDIR(I).EQ.1)THEN                    ! THIS IS INJECTION OF WATER
          WCST = CST(I)
          SUMI = SUMI + WCST
          OBJC = REAL(FVOBJC(I),DP)*WCST
          WRITE(GWMOUT,2100,ERR=990) FVNAME(I),WCST,OBJC
        ELSE                                     ! THIS IS WITHDRAWAL OF WATER
          WCST = -CST(I)
          SUME = SUME + WCST
          OBJC = REAL(FVOBJC(I),DP)*WCST
          WRITE(GWMOUT,2200,ERR=990) FVNAME(I),WCST,OBJC
        ENDIF
        SUMC = SUMC + OBJC
        RANGENAME(I)=FVNAME(I)
        RANGENAMEF(I)=FVNAME(I)
 100  ENDDO
      WRITE(GWMOUT,2300,ERR=990)SUME,SUMI,SUMC
      SUMCT = SUMC
C
C-----WRITE OPTIMAL EXTERNAL VARIABLES
      IF(NEVAR.GT.0)THEN
      SUMC = ZERO
      WRITE(GWMOUT,3000,ERR=990)
      ICST = NFVAR
      DO 200 I=1,NEVAR
        ICST = ICST + 1
        WCST = CST(ICST)
        OBJC = REAL(EVOBJC(I),DP)*WCST 
        WRITE(GWMOUT,3100,ERR=990) EVNAME(I),ETYPED(EVDIR(I)),WCST,OBJC
        SUMC = SUMC + OBJC
        RANGENAME(ICST)=EVNAME(I)
        RANGENAMEF(ICST)=EVNAME(I)
  200 ENDDO
      WRITE(GWMOUT,3200,ERR=990)SUMC
      SUMCT = SUMCT+SUMC
      ENDIF
C
C-----WRITE OPTIMAL BINARY VARIABLES
      IF(NBVAR.GT.0)THEN
      SUMI = ZERO
      SUMC = ZERO
      WRITE(GWMOUT,4000,ERR=990)
      ICST = NFVAR+NEVAR
      DO 300 I=1,NBVAR
        ICST = ICST + 1
        WRITE(GWMOUT,4100,ERR=990) BVNAME(I),INT(CST(ICST)),
     &                             BVOBJC(I)*CST(ICST)
        SUMI = SUMI + CST(ICST)
        SUMC = SUMC + REAL(BVOBJC(I),DP)*CST(ICST)
        RANGENAME(ICST)=BVNAME(I)
        RANGENAMEF(ICST)=BVNAME(I)
  300 ENDDO
      WRITE(GWMOUT,4200,ERR=990)INT(SUMI),SUMC
      SUMCT = SUMCT+SUMC
      ENDIF
C
C-----WRITE OPTIMAL STATE VARIABLES
      IF(STANUM.GT.0)THEN
      SUMI = ZERO
      SUMC = ZERO
      WRITE(GWMOUT,5000,ERR=990)
      DO 500 I=1,STANUM
	  OBJS = ZERO
	  OBJC = ZERO 
	  DO 490 ICST=1,NFVAR
          OBJS = OBJS + STATERES(I,ICST)*CST(ICST)
  490   ENDDO 
        OBJS = OBJS - STARHS(I)
        OBJC = OBJS*SVOBJC(I)                    ! CONTRIBUTION TO OBJ BY SV I
        WRITE(GWMOUT,5100,ERR=990) SVNAME(I),OBJS,OBJC
        SUMI = SUMI + OBJS
	  SUMC = SUMC + OBJC
  500 ENDDO
      WRITE(GWMOUT,5200,ERR=990)SUMI,SUMC
      SUMCT = SUMCT+SUMC
      ENDIF
C
      WRITE(GWMOUT,8000,ERR=990)SUMCT
C
 2000 FORMAT(T8,'OPTIMAL RATES FOR EACH FLOW VARIABLE ',
     &     /,  T8,39('-'),
     &     /,  T1,'Variable',T20,'Withdrawal',
     &         T40,'Injection',T60,'Contribution',
     &     /,  T1,'Name',T20,'Rate',T40,'Rate',T60,'To Objective',
     &     /,  T1,10('-'),T20,14('-'),T40,12('-'),T60,12('-'))
 2100 FORMAT(1P,T2,A,T39,ES13.6,T59,ES13.6)
 2200 FORMAT(1P,T2,A,T19,ES13.6,T59,ES13.6)
 2300 FORMAT(  T20,12('-'),T40,12('-'),T60,12('-'),
     &       /,T1,'TOTALS',T19,ES13.6,T39,ES13.6,T59,ES13.6,/)
 3000 FORMAT(T8,'OPTIMAL VALUES FOR EACH EXTERNAL VARIABLE ',
     &     /,  T8,39('-'),
     &     /,  T1,'Variable',T20,'Variable',
     &         T40,'Optimal',T60,'Contribution',
     &     /,  T1,'Name',T20,'Type',T40,'Value',T60,'To Objective',
     &     /,  T1,10('-'),T20,14('-'),T40,12('-'),T60,12('-'))
 3100 FORMAT(1P,T2,A,T19,A10,T39,ES13.6,T59,ES13.6)
 3200 FORMAT(  T60,12('-'),
     &       /,T1,'TOTAL',T59,ES13.6,/)
 4000 FORMAT(T8,'OPTIMAL VALUES FOR EACH BINARY VARIABLE ',
     &     /,  T8,39('-'),
     &     /,  T1,'Variable',T60,'Contribution',
     &     /,  T1,'Name',T20,'Value',T60,'To Objective',
     &     /,  T1,10('-'),T20,12('-'),T60,12('-'))
 4100 FORMAT(1P,T2,A,T20,I5,T59,ES13.6)
 4200 FORMAT(  T20,12('-'),T60,12('-'),
     &       /,T1,'TOTALS',T20,I5,T59,ES13.6,/)
 5000 FORMAT(T8,'OPTIMAL VALUES FOR EACH STATE VARIABLE ',
     &     /,  T8,39('-'),
     &     /,  T1,'Variable',T60,'Contribution',
     &     /,  T1,'Name',T20,'Value',T60,'To Objective',
     &     /,  T1,10('-'),T20,12('-'),T60,12('-'))
 5100 FORMAT(1P,T2,A,T20,ES13.6,T60,ES13.6)
 5200 FORMAT(  T20,12('-'),T60,12('-'),
     &       /,T1,'TOTALS',T20,ES13.6,T60,ES13.6,/)
 8000 FORMAT(1P,/,T8,'OBJECTIVE FUNCTION VALUE ',T59,ES13.6,/)
C
      RETURN
C
C-----ERROR HANDLING
  990 CONTINUE
C-----FILE-WRITING ERROR
      INQUIRE(GWMOUT,NAME=FLNM,FORM=FMTARG,ACCESS=ACCARG,ACTION=FILACT)
      WRITE(*,9900)TRIM(FLNM),GWMOUT,FMTARG,ACCARG,FILACT
 9900 FORMAT(/,1X,'*** ERROR WRITING FILE "',A,'" ON UNIT ',I5,/,
     &7X,'SPECIFIED FILE FORMAT: ',A,/
     &7X,'SPECIFIED FILE ACCESS: ',A,/
     &7X,'SPECIFIED FILE ACTION: ',A,/
     &2X,'-- STOP EXECUTION (GWM1OBJ3OT)')
      CALL GSTOP(' ')
C
      END SUBROUTINE GWM1OBJ3OT
C
C***********************************************************************
      SUBROUTINE GWM1OBJ3OT2
C***********************************************************************
C     VERSION: 30MAY2011
C     PURPOSE: COMPUTE VALUE OF OBJECTIVE FUNCTION 
C-----------------------------------------------------------------------
      USE GWM1BAS3, ONLY : ZERO,GWMOUT
      USE GWM1DCV3, ONLY : NFVAR,FVBASE,FVDIR
      USE GWM1STA3, ONLY : STANUM,STASTATE
      INTEGER(I4B)::I
      REAL(DP)::SUMC,Q
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
      SUMC = ZERO                                ! INITIALIZE OBJECTIVE VALUE
C-----ADD UP FLOW VARIABLE PORTION OF OBJECTIVE
      DO 100 I=1,NFVAR
        IF(FVDIR(I).EQ.1)THEN                    ! THIS IS INJECTION OF WATER
          Q = FVBASE(I)
        ELSE                                     ! THIS IS WITHDRAWAL OF WATER
          Q = -FVBASE(I)
        ENDIF
        SUMC = SUMC + REAL(FVOBJC(I),DP)*Q
 100  ENDDO
C
C-----ASSUME EXTERNAL VARIABLES TAKE VALUE ZERO
C
C-----ASSUME BINARY VARIABLES TAKE VALUE ZERO
C
C-----ADD UP STATE VARIABLE PORTION OF OBJECTIVE
      IF(STANUM.GT.0)THEN
      DO 500 I=1,STANUM
	  SUMC = SUMC + STASTATE(I)*SVOBJC(I)    
  500 ENDDO
      ENDIF
C
      WRITE(GWMOUT,9000)SUMC
 9000 FORMAT(1P,/,T5,'Value of Flow Variable and State Variable ',/,
     &            T7,'parts of objective function =',T50,ES13.6,/)
C
      RETURN
C
      END SUBROUTINE GWM1OBJ3OT2
C
C
      END MODULE GWM1OBJ3