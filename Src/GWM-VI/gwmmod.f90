MODULE GWMMOD
  USE GWMDATA
  USE PLLM, ONLY: PLLM_USTOP
  PRIVATE
  !   Public subprograms
  PUBLIC MAIN_INI, MAIN_INI_EQN, MAIN_INI_DEP, MAIN_INI_PARS,  &
         MAIN_INI_PAR_CLOSURE, MAIN_GEN, MAIN_UEV, MAIN_WRITEPARS, &
         MAIN_DEF, MAIN_CLN, DECVARS_TO_PVAL, MAIN_WRITE_MIF_BLOCK, &
         MAIN_WRITE_MOF_BLOCK, MAIN_WRITE_MF_STATUS_JIF
  PUBLIC :: MAIN_GET_MFCNVRG
  !   Public variables
  PUBLIC :: SIMCOMMAND
  INTEGER, PARAMETER :: I4B = SELECTED_INT_KIND(9)
  INTEGER, PARAMETER :: DP = KIND(1.0D0)
  CHARACTER(LEN=2000) :: SIMCOMMAND
CONTAINS
  !-----------------------------------------------------------------------------
  SUBROUTINE MAIN_INI(INGWM,GWMOUT,NAMFILE)
    !   Read GWM file to define CONTROL file name; rewind GWM file.
    USE DATATYPES
    USE UTILITIES
    USE GLOBAL_DATA, ONLY: BIGDOUBLE, IVERB, LENDNAM, MAX_STRING_LEN
    USE GLOBAL, ONLY: IUNIT
    USE BASIC, ONLY: DERIV_INTERFACE
    USE GWM_SUBS, ONLY: EPSQNET
    IMPLICIT NONE
    !
    !   Argument-list variables
    INTEGER, INTENT(IN)  :: INGWM
    INTEGER, INTENT(IN)  :: GWMOUT
    CHARACTER*2000 NAMFILE  ! TEMP WAY TO HANDLE PASSING NAME
    !
    !   Local variables
    CHARACTER(LEN=MAX_STRING_LEN)   :: FILEIN=' '  ! Input data file name
    CHARACTER(LEN=MAX_STRING_LEN)   :: LINE,DISFILE,CTRLFILE,MESSFILE
    CHARACTER(LEN=40), DIMENSION(1) :: COLNAMES
    CHARACTER(LEN=10) :: FTYPE
    INTEGER :: ICOL, IERR, ISTART, ISTAT, ISTOP, KLCD, NDUM
    INTEGER :: INNAM, KOPT, KGWM, KSIM
    REAL :: RDUM
    DOUBLE PRECISION :: HOBDRYTEMP, EPSQNETTEMP
    !
    !   Format statements
    10  FORMAT(A)
    50  FORMAT(1X,'Messages generated by GWM-VI',/)
    80  FORMAT(/,1X,'Reading input from file: ',A)
    100 FORMAT(/,1X,A,1X,I4)
    120 FORMAT(1X,A,1X,A)
    140 FORMAT(1X,'EPSQNET assigned as ',G11.4)
    !    
    !   Initialize variables
    NULLIFY(OPTHEAD) ! Pointer to head of Options input-block list
    NULLIFY(SIMHEAD) ! Pointer to head of Simulation input-block list
    NULLIFY(MCLHEAD) ! Pointer to head of Model_Command_Lines input-block list
    NULLIFY(MIFHEAD) ! Pointer to head of Model_Input_Files input-block list
    NULLIFY(MOFHEAD) ! Pointer to head of Model_Output_Files input-block list
    NULLIFY(PLLHEAD) ! Pointer to head of Parallel_Control input-block list
    NULLIFY(RUNHEAD) ! Pointer to head of Parallel_Runners input-block list
    NULLIFY(TAIL)
    !
    DISFILE = ' '
    CTRLFILE = ' '
    MESSFILE = ' '
    WELLFILE = ' '
    INCTRL = 0
    INNAM = 0
    COLNAMES(1) = ' '
    DERIV_INTERFACE = ' '
    PRECISION = 'double'
    HOBDRYTEMP = BIGDOUBLE
    !
    FILEIN = UTL_GETARG()  ! Get command-line argument (may be commented-out)
    IF (FILEIN==' ') THEN
      WRITE(*,10)' Enter name of GWM-VI input file:'
      READ(*,10)FILEIN
      IF (FILEIN==' ') CALL PLLM_USTOP('No input file entered')
    ENDIF
    !
    !   Open the input data file
    OPEN(UNIT=INGWM,FILE=FILEIN,STATUS='OLD',IOSTAT=ISTAT)
    IF (ISTAT .NE. 0) THEN
      WRITE(*,'(1X,A,I6)') 'File open failed--status = ',istat
      CALL PLLM_USTOP(' ')
    ENDIF
    WRITE(GWMOUT,80) TRIM(FILEIN)
    !
    !   Find and read CONTROL and DIS files
    DO WHILE (INCTRL==0 .OR. INNAM==0)
      LINE = UTL_GETLINE(INGWM,GWMOUT)
      ICOL = 1
      IF (LINE.NE.' ') THEN
        CALL UTL_RWORD(GWMOUT,0,.TRUE.,ICOL,LINE,ISTART, &
                       ISTOP,NDUM,RDUM,INGWM)
        FTYPE = LINE(ISTART:ISTOP)
        !   Check for CONTROL file
        IF (FTYPE=='CONTROL') THEN
          !
          ! Open CONTROL file containing JUPITER input blocks
          CALL UTL_RWORD(GWMOUT,0,.FALSE.,ICOL,LINE,ISTART, &
                         ISTOP,NDUM,RDUM,INGWM)          
          CTRLFILE = LINE(ISTART:ISTOP)
          WRITE(GWMOUT,120)'CONTROL file:',TRIM(CTRLFILE)
          INCTRL = UTL_GETUNIT(980,1000)
          OPEN(INCTRL,FILE=CTRLFILE,STATUS='OLD',IOSTAT=ISTAT)
          IF (ISTAT .NE. 0) THEN
            WRITE(*,30)TRIM(CTRLFILE)
            30 FORMAT(1X,'Error opening CONTROL file: ',A)
            CALL PLLM_USTOP('')
          ENDIF
        ELSEIF (FTYPE=='NAM') THEN
          !
          ! Obtain the name of the NAM file and write it to a temporary location
          CALL UTL_RWORD(GWMOUT,0,.FALSE.,ICOL,LINE,ISTART, &
                         ISTOP,NDUM,RDUM,INGWM)          
          NAMFILE = LINE(ISTART:ISTOP)
          WRITE(GWMOUT,120)'NAM file:',TRIM(NAMFILE)
          INNAM = 1
        ENDIF
      ELSE
        ! EOF encountered
        IF (INCTRL==0) THEN
          WRITE(GWMOUT,*)'CONTROL file not found in GWM input file'
          WRITE(*,*)'CONTROL file not found in GWM input file'
        ENDIF
        IF (INNAM==0) THEN
          WRITE(GWMOUT,*)'NAM file not found in GWM input file'
          WRITE(*,*)'NAM file not found in GWM input file'
        ENDIF 
        ! At this point, GWMOUT is a scratch file, so anything
        ! written to it is lost when execution ends. 
        CALL PLLM_USTOP('End of GWM input file encountered',GWMOUT)
      ENDIF
    ENDDO
    REWIND(INGWM)
    !
    ! Read Options block from CONTROL file to define IOUTMESS, IVERB, WELLFILE
    KOPT = 0
    CALL UTL_READBLOCK(1,'OPTIONS',COLNAMES,INCTRL,GWMOUT,'*',.FALSE.,   &
                       OPTHEAD,TAIL,KOPT)
    IERR = 0
    IOUTMESS = GWMOUT
    CALL UTL_FILTER(IERR,OPTHEAD,GWMOUT,'MESSAGEFILE',MESSFILE)
    IF (MESSFILE .NE. ' ') THEN
      IOUTMESS = UTL_GETUNIT(980,1000)
      OPEN(IOUTMESS,FILE=MESSFILE,IOSTAT=ISTAT,STATUS='REPLACE')
      IF (ISTAT.NE.0) THEN
        WRITE(*,40)TRIM(MESSFILE)
        40 FORMAT(1X,'ERROR opening file: ',A)
        CALL PLLM_USTOP()
      ENDIF
      WRITE(IOUTMESS,50)
    ENDIF
    CALL UTL_FILTER(IERR,OPTHEAD,IOUTMESS,'VERBOSE',IVERB)
    IF (IERR .NE. 0) CALL PLLM_USTOP('Error reading from Options block')
    CALL UTL_FILTER(IERR,OPTHEAD,IOUTMESS,'WELLFILE',WELLFILE)
    CALL UTL_FILTER(IERR,OPTHEAD,IOUTMESS,'HOBDRY',HOBDRYTEMP)
    EPSQNETTEMP = 0.0D0
    CALL UTL_FILTER(IERR,OPTHEAD,IOUTMESS,'EPSQNET',EPSQNETTEMP)
    IF (EPSQNETTEMP.NE.0.0D0) THEN
      EPSQNET = EPSQNETTEMP
      WRITE(GWMOUT,140)EPSQNET
    ENDIF
    IF (HOBDRYTEMP==BIGDOUBLE) THEN
      HOBDRYSET = .FALSE.
    ELSE
      HOBDRY = HOBDRYTEMP
      HOBDRYSET = .TRUE.
    ENDIF
    KSIM= 0
    CALL UTL_READBLOCK(1,'SIMULATION',COLNAMES,INCTRL,IOUTMESS,'*',.TRUE.,   &
                       SIMHEAD,TAIL,KSIM)
    CALL UTL_FILTER(IERR,SIMHEAD,IOUTMESS,'SIMCOMMAND',SIMCOMMAND)
    !
    RETURN
  END SUBROUTINE MAIN_INI
  !-----------------------------------------------------------------------------
  SUBROUTINE MAIN_INI_PARS(INGWM,NFVAR,FVMIN,FVMAX,FVBASE, &
                           FVNCELL,FVNAME,NPT,NPE,NPD,OK)
    !   Store parameter-related data
    USE DATATYPES
    USE GLOBAL_DATA, ONLY: AMESSAGE, BIGDOUBLE, IVERB, MAX_STRING_LEN
    USE UTILITIES
    IMPLICIT NONE
    !
    !   Argument-list variables
    INTEGER, INTENT(IN)  :: INGWM
    INTEGER, INTENT(IN)  :: NFVAR
    REAL(DP), DIMENSION(NFVAR), INTENT(IN) :: FVMIN, FVMAX, FVBASE
    INTEGER, DIMENSION(NFVAR), INTENT(IN) :: FVNCELL
    CHARACTER(LEN=10), DIMENSION(NFVAR), INTENT(IN) :: FVNAME
    INTEGER, INTENT(OUT) :: NPT       ! Number of parameters
    INTEGER, INTENT(OUT) :: NPE       ! Number of parameters with adjustable=yes
    INTEGER, INTENT(OUT) :: NPD       ! Number of derived parameters
    LOGICAL, INTENT(INOUT) :: OK
    !
    !   Local variables
    INTEGER               :: I, IERR, IFAIL, KPE, KPGP, KPV, MORE
    CHARACTER (LEN=10)    :: ATEMP
    CHARACTER(LEN=12)     :: DEFGROUP
    CHARACTER(LEN=80)     :: TITLE
    LOGICAL :: OKLOCAL
    !
    !   Format statements
    100 FORMAT(/,1X,A)
    200 FORMAT(1X,I6,' Error(s) encountered -- STOP EXECUTION (MAIN_INI_PARS)')
    !
    OKLOCAL = .TRUE.
    IFAIL=0
    DEFGROUP = 'DefaultPar'
    !
    ATEMP=ADJUSTL(PRECISION)
    CALL UTL_CASETRANS(ATEMP,'lo')
    IF(ATEMP(1:6).EQ.'double')THEN
      PRECISPRO=1
    ELSE
      PRECISPRO=0
    END IF
    ATEMP=ADJUSTL(DECPOINT)
    CALL UTL_CASETRANS(ATEMP,'lo')
    IF(ATEMP(1:7).EQ.'nopoint')THEN
      NOPNT=1
    ELSE
      NOPNT=0
    END IF
    !
    NPT = 0
    CALL MAIN_INI_COUNTPARS(NPT,NFVAR,FVNCELL)
    !
    NPTC = NPT
    !   Allocate arrays for parameter-related data
    ALLOCATE (DELB(NPTC), NW(NPTC), PADJ(NPTC),  &
              PARGP(NPTC), PARNAM(NPTC), PASSIGNED(NPTC),    &
              PERTURBMIN(NPTC), PERTURBRAT(NPTC), PVAL(NPTC),  &
              PVALFWD(NPTC), PVALMAX(NPTC), PVALMIN(NPTC),  &
              PVALTMP(NPTC))
    !
    !   Populate arrays with default values
    PADJ = .FALSE.
    PARGP = DEFGROUP
    PARNAM = ' '
    PASSIGNED = .FALSE.
    PVAL = BIGDOUBLE
    PVALMAX = BIGDOUBLE
    PVALMIN = BIGDOUBLE
    PERTURBMIN = 0.0D0
    !
    !   Filter information in linked list and populate arrays in the PARAMSET
    !   structure
    IERR = 0
    ! Populate arrays (PARNAM, ...) using data read from GWM files.
    ! There will be no PARAMETER_DATA input block
    CALL MAIN_INI_DEFPARNAM(NPT,NFVAR,FVNAME,FVNCELL,OKLOCAL)
    IF (.NOT. OKLOCAL) GOTO 999
    ! Populate PVAL and other arrays with values read from VARCON file
    CALL MAIN_INI_ARRAYS(NPT,NFVAR,FVMIN,FVMAX,FVBASE,OKLOCAL)
    IF (.NOT. OKLOCAL) GOTO 999
    !
    !   Count number of parameters for which ADJUSTABLE is true.
    NPE = 0
    DO I=1,NPTC
      IF (PVAL(I) .NE. BIGDOUBLE) PASSIGNED(I)=.TRUE.
      IF (PADJ(I)) THEN
        NPE = NPE + 1
      ENDIF
    ENDDO
    !
    IF (IVERB>3) THEN
      !   Write parameter information to output file
      WRITE(IOUTMESS,*)' '
      WRITE(IOUTMESS,100)'PARAMETER INFORMATION:'
      CALL MAIN_WRITEPARS(NPTC)
    ENDIF
    CALL UTL_CHECK_NAMES(IOUTMESS,NPTC,PARNAM)
    !
    !   Allocate and populate arrays for parameters being estimated or analyzed
    IF (NPE .GT. 0) THEN
      ALLOCATE (IPTR(NPE),BINC(NPE))
      KPE = 0
      DO I=1,NPT
        IF (PADJ(I)) THEN
          KPE = KPE + 1
          IPTR(KPE) = I
        ENDIF
      ENDDO
    ELSE
      IF (IVERB .GT. 0) WRITE(IOUTMESS,300)
      300 FORMAT(/,1X,'*** Warning: No parameters for which ADJUSTABLE="YES"',/)
    ENDIF
    !
    !   Write information for adjustable parameters to output file
    WRITE(IOUTMESS,*)' '
    IF (NPE>0 .AND. IVERB>2) THEN
      TITLE = 'INFORMATION FOR PARAMETERS CORRESPONDING' //   &
              ' TO FLOW-RATE DECISION VARIABLES:'
      WRITE(IOUTMESS,100)TRIM(TITLE)
      CALL MAIN_WRITEEPARS(NPE)
    ENDIF
    IF (IERR > 0) THEN
      WRITE(IOUTMESS,200) IERR
      OKLOCAL = .FALSE.
      GOTO 999
    ENDIF
    NPD = NPT-NPE
    !
    999 CONTINUE
    IF (OK) OK = OKLOCAL
    RETURN
  END SUBROUTINE MAIN_INI_PARS
  !-----------------------------------------------------------------------------
  SUBROUTINE MAIN_INI_ARRAYS(NPT,NFVAR,FVMIN,FVMAX,FVBASE,OK)
    !   Populate GWMMOD arrays with data read from GWM input files: VARCON, others?
    !   GWMMOD arrays have an element for each parameter.  There is a parameter
    !   for each flow-rate decision variables and for each cell (when NC>1) 
    !   controlled by each flow-rate decision variable
    USE GWM1DCV3, ONLY : GWM1DCV3FVCPNT,FVRATIO,FVNCELL
    USE UTILITIES
    IMPLICIT NONE
    !   Argument-list variables
    INTEGER, INTENT(IN) :: NPT, NFVAR
    REAL(DP), DIMENSION(NFVAR), INTENT(IN) :: FVMIN, FVMAX, FVBASE
    LOGICAL, INTENT(INOUT) :: OK
    !   Local variables
    INTEGER :: I, KC, KDV, NCMAX
    DOUBLE PRECISION :: PVALTEMP, PVMINTEMP, PVMAXTEMP
    LOGICAL :: OKLOCAL
    !   Format statements
    10 FORMAT(1X,'Programmer error in MAIN_INI_ARRAYS: KDV (',   &
              I5,') > NFVAR (',I5,')')
    20 FORMAT(1X,'Programmer error in MAIN_INI_ARRAYS: KC (',   &
              I5,') > NCMAX (',I5,')')
    !
    OKLOCAL = .TRUE.
    KDV = 0      ! Index in list of decision variables
    DO I=1,NPT
      IF (PADJ(I)) THEN
        KDV = KDV + 1  ! Only flow-rate decision variables are adjustable
        KC = 0         ! Index in list of cells controlled by each dec. var.
        CALL GWM1DCV3FVCPNT(KDV)  ! Point to correct arrays for FVRATIO
        NCMAX = ABS(FVNCELL(KDV)) ! Number of cells for this decision variable
      ELSE
        KC = KC + 1
      ENDIF
      IF (KDV>NFVAR) THEN
        WRITE(*,10)KDV,NFVAR
        OKLOCAL = .FALSE.
        GOTO 999
      ENDIF
      IF (KC>NCMAX) THEN
        WRITE(*,20)KC,NCMAX
        OKLOCAL = .FALSE.
        GOTO 999
      ENDIF
      IF (PADJ(I)) THEN
        !   Flow-rate decision variable
        PVALTEMP = FVBASE(KDV)
        PVMINTEMP = FVMIN(KDV)
        PVMAXTEMP = FVMAX(KDV)
        PVAL(I) = PVALTEMP
        PVALMIN(I) = PVMINTEMP
        PVALMAX(I) = PVMAXTEMP
      ELSE
        !   Flow-rate decision variable * RATIO applies to one of multiple cells
        PVAL(I) = PVALTEMP * FVRATIO(KC)
        PVALMIN(I) = PVMINTEMP * FVRATIO(KC)
        PVALMAX(I) = PVMAXTEMP * FVRATIO(KC)
      ENDIF
    ENDDO
    !
    999 CONTINUE
    IF (OK) OK = OKLOCAL
    RETURN
  END SUBROUTINE MAIN_INI_ARRAYS
  !-----------------------------------------------------------------------------
  SUBROUTINE MAIN_INI_PAR_CLOSURE(NPTC)
    !   Define a non-adjustable parameter to hold HCLOSE
    IMPLICIT NONE
    !   Argument-list variables
    INTEGER, INTENT(IN) :: NPTC
    PARNAM(NPTC) = 'HCLOSE'
    PADJ(NPTC) = .FALSE.
    PVAL(NPTC) = HCLOSET
    PVALMIN(NPTC) = HCLOSET
    PVALMAX(NPTC) = HCLOSET
    RETURN    
  END SUBROUTINE MAIN_INI_PAR_CLOSURE
  !-----------------------------------------------------------------------------
  SUBROUTINE MAIN_INI_COUNTPARS(NPARAM,NFVAR,FVNCELL)
    IMPLICIT NONE
    !   Argument-list variables
    INTEGER, INTENT(IN) :: NFVAR
    INTEGER(I4B), DIMENSION(NFVAR) :: FVNCELL
    INTEGER, INTENT(OUT) :: NPARAM
    !   Local variables
    INTEGER :: J, NC
    !
    NPARAM = 0
    DO J=1,NFVAR
      NPARAM = NPARAM + 1  ! One name for each decision variable
      NC = ABS(FVNCELL(J))
      IF (NC>1) THEN
        ! An additional name is required for each cell when
        ! decision variable is distributed over multiple cells
        NPARAM = NPARAM + NC
      ENDIF
    ENDDO
    RETURN
  END SUBROUTINE MAIN_INI_COUNTPARS
  !-----------------------------------------------------------------------------
  SUBROUTINE MAIN_INI_DEFPARNAM(NPT,NFVAR,FVNAME,FVNCELL,OK)
    !   Define parameter names based on data 
    !   read from DECVAR file: FVNAME // cell number (1 through NC)
    USE UTILITIES
    USE GWM_UTLS, ONLY: APPEND_MESSAGE
    USE GWM_SUBS, ONLY: I_BASE36_3
    USE GWM1DCV3, ONLY: FVMNW
    IMPLICIT NONE
    !   Argument-list variables
    INTEGER, INTENT(IN) :: NPT ! Number of parameters, including derived parameters
    INTEGER, INTENT(IN) :: NFVAR
    CHARACTER(LEN=10), DIMENSION(NFVAR), INTENT(IN) :: FVNAME
    INTEGER(I4B), DIMENSION(NFVAR), INTENT(IN) :: FVNCELL
    LOGICAL, INTENT(INOUT) :: OK
    !   Local variables
    CHARACTER(LEN=13) :: TEMPNAM
    INTEGER :: I, J, K, L, NAMLEN, NC, NMNW
    LOGICAL :: OKLOCAL
    !
    OKLOCAL = .TRUE.
    K = 0
    DO I = 1, NFVAR        ! For each flow-rate decision variable in DECVAR file
      TEMPNAM = FVNAME(I)  ! Get the decision variable name
      K = K+1
      IF (K>NPT) THEN 
        OKLOCAL = .FALSE.
        CALL APPEND_MESSAGE('Programming error caught in MAIN_INI_DEFPARNAM')
        GOTO 999
      ENDIF
      PARNAM(K) = TEMPNAM  ! Store the decision variable name
      PADJ(K) = .TRUE. ! In GWM, all flow-rate decision variables are adjustable
      IF (FVNCELL(I) > 0) THEN
        ! Decision variable uses WEL Package
        NC = FVNCELL(I)
        IF (NC>1) THEN
          ! When the WEL type decision variable controls multiple cells,
          ! an additional, derived parameter is needed for each cell
          NAMLEN = LEN_TRIM(TEMPNAM)
          TEMPNAM = '__________   '         ! Ten underscore characters, three blanks
          TEMPNAM(1:NAMLEN) = TRIM(FVNAME(I))
          DO J=1,NC
            ! Add sequential cell number (in base-36) to GWM name to form PARNAM
            TEMPNAM(11:13) = I_BASE36_3(J) 
            K = K+1
            IF (K>NPT)THEN
              CALL APPEND_MESSAGE('Programming error caught in MAIN_INI_DEFPARNAM')
              OKLOCAL = .FALSE.
              GOTO 999
            ENDIF
            PARNAM(K) = TEMPNAM
          ENDDO
        ENDIF
      ELSEIF (FVNCELL(I) < 0) THEN
        ! Decision variable uses MNW2 Package
        ! NMNW is the number of MNW wells included in flow variable I
        NMNW = ABS(FVNCELL(I))
        DO J=1,NMNW
          IF (J>1) K = K + 1
          IF (K>NPT) THEN
            CALL APPEND_MESSAGE('Programming error caught in MAIN_INI_DEFPARNAM')
            OKLOCAL = .FALSE.
            GOTO 999
          ENDIF
          PARNAM(K) = FVMNW(I)%FVWELLID(J)
        ENDDO
      ENDIF
    ENDDO
    999 CONTINUE
    IF (OK) OK = OKLOCAL
    RETURN
  END SUBROUTINE MAIN_INI_DEFPARNAM
  !-----------------------------------------------------------------------------
  SUBROUTINE MAIN_INI_DEP(NCOVMAT,NHB,NDD,NDF,NGD,HDCNAME,STCNUM,STCNAME, &
                          STANUM,SVNAME,NHVAR,NRVAR,NSVAR,NDVAR,NSTADEP,SVILOC)
    !   Allocate arrays related to dependents, and populate with defaults.
    !   Write a PREDICTION_DATA input block to a scratch file, 
    !   then call DEP_INI_READ 
    USE GLOBAL_DATA, ONLY: BIGDOUBLE
    USE UTILITIES
    USE DEPENDENTS
    IMPLICIT NONE
    !   Argument-list variables
    INTEGER, INTENT(INOUT) :: NCOVMAT
    INTEGER, INTENT(IN) :: NHB, NDD, NDF, NGD, STCNUM
    INTEGER, INTENT(IN) :: STANUM, NHVAR, NRVAR, NSVAR, NDVAR, NSTADEP, &
                           SVILOC(STANUM)
    CHARACTER(LEN=10), INTENT(IN) :: HDCNAME(NHB+NDD+NDF+NGD), &
                                     STCNAME(STCNUM), &
                                     SVNAME(STANUM)
    !   Local variables
    INTEGER :: ISCRATCH 
    !
    !   Use data read from GWM input files to Write an OBSERVATION_DATA input
    !   block to scratch file opened on unit ISCRATCH
    ISCRATCH = UTL_GETUNIT(7,2000)
    OPEN(ISCRATCH,STATUS='SCRATCH')
    CALL MAIN_INI_WRITE_PREDDATA(ISCRATCH,NHB,NDD,NDF,NGD,HDCNAME,STCNUM, &
                                 STCNAME, STANUM,SVNAME,NHVAR,NRVAR,NSVAR, &
                                 NDVAR,NSTADEP,SVILOC)
    REWIND(ISCRATCH)
    CALL DEP_INI_READ(2,ISCRATCH,IOUTMESS,NCOVMAT,NDEPSTAT,NDDEP,NEDEP,NTDEP)
    CLOSE(ISCRATCH)
    !
    ALLOCATE(DNPP(NDEPSTAT,2))
    IF (NDEPSTAT>0) THEN
      ALLOCATE(OBSNAM(NDEPSTAT),MODELVAL(NDEPSTAT),TEMPVAL(NDEPSTAT))
      ! Activate extraction of simulated equivalents to observations
      MCVUSE(1) = .TRUE.  
      OBSNAM = ' '
      MODELVAL = BIGDOUBLE
      WTVEC = BIGDOUBLE
      TEMPVAL = BIGDOUBLE
    ENDIF
  END SUBROUTINE MAIN_INI_DEP
  !-----------------------------------------------------------------------------
  SUBROUTINE MAIN_INI_WRITE_PREDDATA(IU,NHB,NDD,NDF,NGD,HDCNAME,STCNUM, &
                                     STCNAME, STANUM,SVNAME,NHVAR,NRVAR, &
                                     NSVAR,NDVAR,NSTADEP,SVILOC)
    !   Write a PREDICTION_DATA input block to unit IU
    USE GWM_UTLS, ONLY: SAVE_FILE
    USE GWM_SUBS, ONLY: TO_LONGNAME
    IMPLICIT NONE
    !   Argument-list variables
    INTEGER, INTENT(IN) :: IU
    INTEGER, INTENT(IN) :: NHB, NDD, NDF, NGD, STCNUM
    INTEGER, INTENT(IN) :: STANUM, NHVAR, NRVAR, NSVAR, NDVAR, NSTADEP, &
                           SVILOC(STANUM)
    CHARACTER(LEN=10), INTENT(IN) :: HDCNAME(NHB+NDD+NDF+NGD), &
                                     STCNAME(STCNUM), SVNAME(STANUM)
    !   Local variables
    INTEGER :: I, K, ISTRT
    REAL :: STAT, REFVAL
    CHARACTER(LEN=3) :: STATFLAG
    CHARACTER(LEN=13) :: TEMPDEPNAM
    !   Format statements
    10 FORMAT(A)
    20 FORMAT(2X,'NROW=',I9,2X,'NCOL=4  COLUMNLABELS')
    30 FORMAT(2X,'PredName',T17,'MeasStatistic',T32,'MeasStatflag',T46, &
              'RefValue')
    40 FORMAT(2X,A,T17,F4.1,T32,A,T46,F4.1)
    !
    STAT = 1.0
    REFVAL = 0.0
    STATFLAG = 'Var'
    NDEP = NHB + NDD + NDF*2 + NGD*2 + STCNUM 
    NDEP = NDEP + NSTADEP        ! Add dependents related to state variables
    ! Add "dependents": 1 for MODFLOW_STAT, 1 for DEWATER_STAT
    NDEPSTAT = NDEP + 2 
    WRITE(IU,10)'BEGIN Prediction_Data TABLE'
    WRITE(IU,20)NDEPSTAT
    WRITE(IU,30)
    K = 0         ! Index in HDCNAME array
    !
    !   Dependents for head constraints
    IF (NHB>0) THEN
      DO I=1,NHB
        K = K+1
        WRITE(IU,40)TRIM(HDCNAME(K)),STAT,STATFLAG,REFVAL
      ENDDO
    ENDIF
    !
    !   Dependents for drawdown constraints
    IF (NDD>0) THEN
      DO I=1,NDD
        K = K+1
        WRITE(IU,40)TRIM(HDCNAME(K)),STAT,STATFLAG,REFVAL
      ENDDO
    ENDIF
    !
    !   Dependents for head-difference constraints
    IF (NDF>0) THEN
      DO I=1,NDF
        K = K+1
        CALL TO_LONGNAME(HDCNAME(K),TEMPDEPNAM,1)
        WRITE(IU,40)TEMPDEPNAM,STAT,STATFLAG,REFVAL
        CALL TO_LONGNAME(HDCNAME(K),TEMPDEPNAM,2)
        WRITE(IU,40)TEMPDEPNAM,STAT,STATFLAG,REFVAL
      ENDDO
    ENDIF
    !
    !   Dependents for gradient constraints
    IF (NGD>0) THEN
      DO I=1,NGD
        K = K+1
        CALL TO_LONGNAME(HDCNAME(K),TEMPDEPNAM,1)
        WRITE(IU,40)TEMPDEPNAM,STAT,STATFLAG,REFVAL
        CALL TO_LONGNAME(HDCNAME(K),TEMPDEPNAM,2)
        WRITE(IU,40)TEMPDEPNAM,STAT,STATFLAG,REFVAL
      ENDDO
    ENDIF
    !
    K = 0         ! Index in STCNAME array
    !   Dependents for all types of stream-flow constraints
    IF (STCNUM> 0) THEN
      DO I=1,STCNUM
        K = K+1
        WRITE(IU,40)TRIM(STCNAME(K)),STAT,STATFLAG,REFVAL
      ENDDO
    ENDIF
    !
    !   Dependents for state-variable constraints
    IF (STANUM>0) THEN
      !   Loop over head, streamflow and storage state variables
      ISTRT = NHVAR+NRVAR+NSVAR
      DO I=1,ISTRT
        WRITE(IU,40)TRIM(SVNAME(I)),STAT,STATFLAG,REFVAL
      ENDDO
      !   Drain state variables have a dependent for each cell 
      DO I=ISTRT+1,ISTRT+NDVAR
        DO K=1,SVILOC(I)
          CALL TO_LONGNAME(SVNAME(I),TEMPDEPNAM,K)
          WRITE(IU,40)TEMPDEPNAM,STAT,STATFLAG,REFVAL
        ENDDO 
      ENDDO 
    ENDIF
!
    WRITE(IU,40)'MODFLOW_STAT',STAT,STATFLAG,REFVAL
    WRITE(IU,40)'DEWATER_STAT',STAT,STATFLAG,REFVAL
    !
    WRITE(IU,10)'END Prediction_Data'
    !
    ! Retain following commented-out line for debugging purposes
    !CALL SAVE_FILE(IU,'pred_block.txt')
    RETURN
  END SUBROUTINE MAIN_INI_WRITE_PREDDATA
  !-----------------------------------------------------------------------------
  SUBROUTINE MAIN_DEF(GWMOUT,JOBDIM,JOBLEN,NPE,CTRLJOB,NEEDSENS,FIRSTSIM,  &
                      LASTSIM,FINISH,CTRLDONE,ICTRL,SENSDONE,  &
                      KPPL,NUMPPL)
    !   Determine job of current iteration of control loop
    USE GLOBAL_DATA, ONLY: IVERB
    USE BASIC, ONLY: COMPURPOSE, NCOMLINES
    IMPLICIT NONE
    !
    !   Argument-list variables
    INTEGER,                             INTENT(IN)      :: GWMOUT
    INTEGER,                             INTENT(IN)      :: JOBDIM
    INTEGER,                             INTENT(IN)      :: JOBLEN
    INTEGER,                             INTENT(IN)      :: NPE
    CHARACTER(LEN=JOBLEN), DIMENSION(JOBDIM), INTENT(IN) :: CTRLJOB
    LOGICAL,                             INTENT(IN)      :: NEEDSENS
    LOGICAL,                             INTENT(IN)      :: FIRSTSIM
    LOGICAL,                             INTENT(IN)      :: LASTSIM
    LOGICAL,                             INTENT(IN)      :: FINISH
    LOGICAL,                             INTENT(INOUT)   :: CTRLDONE
    INTEGER,                             INTENT(INOUT)   :: ICTRL
    LOGICAL,                             INTENT(INOUT)   :: SENSDONE
    INTEGER,                             INTENT(OUT)     :: KPPL
    INTEGER,                             INTENT(OUT)     :: NUMPPL
    !
    !   Local variables
    CHARACTER(LEN=JOBLEN) :: JOB
    INTEGER :: IPTRKPE, KPE
    LOGICAL :: CHECKNEW
    !
    !   Format statements
    100 FORMAT(/,1X,'Job of current iteration of Control Loop is: ',A)
    140 FORMAT(1X,'NOTE: For parameter "',A,   &
        '", Perturbation increment set to PERTURBMIN value: ',G9.3)
    160 FORMAT(1X,'MAXIMUM ITERATIONS EXCEEDED')
    !
    KPPL = 0
    !   Advance counter ICTRL if appropriate, based on job last iteration
    IF (ICTRL .EQ. 0 .OR. FIRSTSIM) THEN
      ICTRL = 1
    ELSE
      JOB = CTRLJOB(ICTRL)
      IF (JOB .EQ. 'FORWARD') THEN
        ICTRL = ICTRL + 1
      ELSEIF (JOB .EQ. 'SENSITIVITY') THEN
        IF (SENSDONE) ICTRL = ICTRL + 1
      ELSEIF (JOB .EQ. 'REPEAT') THEN
        ICTRL = 1
      ELSE
        ICTRL = ICTRL + 1
      ENDIF
    ENDIF
    JOB = CTRLJOB(ICTRL)
    IF (LASTSIM) ICTRL = 1
    !
    IF (FINISH) THEN
      ICTRL = JOBDIM
    ENDIF
    !
    JOB = CTRLJOB(ICTRL)
    WRITE(IOUTMESS,100) TRIM(JOB)
    WRITE(*,100) TRIM(JOB)
    NUMPPL = 0
    IF (JOB=='FORWARD') THEN
      NUMPPL = 1
    ELSEIF (JOB=='SENSITIVITY') THEN
      !   Assign perturbation amount for each parameter
      DO KPE=1,NPE
        NUMPPL = NUMPPL+1
      ENDDO
    ELSEIF (JOB=='STOP') THEN
      CTRLDONE = .TRUE.
    ENDIF
    !
    RETURN
    !
  END SUBROUTINE MAIN_DEF
  !-----------------------------------------------------------------------------
  SUBROUTINE MAIN_GEN(CTRLJOB,KPPL,NPE,NPT,NFVAR,IOUT,DELINC,IPTR,  &
                      NOPNT,NW,PARNAM,FVBASE,KPE,PSETTMP,OK)
    !   Generate one set of parameter values for one iteration of potentially
    !   parallel loop.  For the parameter being perturbed, ensure that perturbed
    !   value equals value that will be written to model-input files, and that
    !   perturbation amount (DELB) equals the difference of the (potentially
    !   precision-limited) perturbed and unperturbed parameter values.
    USE GLOBAL_DATA, ONLY: IVERB
    USE UTILITIES
    ! for debugging
!    use gwm1bas3, only : gwmout
    IMPLICIT NONE
    !
    !   Argument-list variables
    CHARACTER(LEN=*),                  INTENT(IN)    :: CTRLJOB
    INTEGER,                           INTENT(IN)    :: KPPL ! Index of parameter to be perturbed
    INTEGER,                           INTENT(IN)    :: NPE
    INTEGER,                           INTENT(IN)    :: NPT     ! Number of parameters
    INTEGER,                           INTENT(IN)    :: NFVAR
    INTEGER,                           INTENT(IN)    :: IOUT
    DOUBLE PRECISION,  DIMENSION(NFVAR), INTENT(IN)  :: DELINC    ! Perturbation increment for each parameter
    INTEGER,           DIMENSION(NPE), INTENT(IN)    :: IPTR
    INTEGER,                           INTENT(IN)    :: NOPNT
    INTEGER,           DIMENSION(NPT), INTENT(IN)    :: NW      ! Minimum word length of a parameter
    CHARACTER(LEN=*),  DIMENSION(NPT), INTENT(IN)    :: PARNAM  ! Parameter names
    DOUBLE PRECISION,  DIMENSION(NFVAR), INTENT(IN)  :: FVBASE    ! Current parameter values
    INTEGER,                           INTENT(OUT)   :: KPE
    DOUBLE PRECISION,  DIMENSION(NPE), INTENT(OUT)   :: PSETTMP ! Parameter temporary values
    LOGICAL, INTENT(INOUT) :: OK
    !
    !   Local variables
    INTEGER            :: I, IFAIL, IP, IPTRI, K, KINC, PRECPR
    DOUBLE PRECISION   :: PERTVAL ! Perturbed parameter value
    DOUBLE PRECISION   :: PSIGN   ! Multiplier that implements perturbation direction
    CHARACTER (LEN=25) :: WORD  ! Character representation of perturbed parameter value
    CHARACTER(LEN=8)   :: PERTURBDIRECTION
    LOGICAL :: OKLOCAL
    !
    !   Format statements
    100 FORMAT(/,   &
        1X,'PARAMETER',9X,'VALUE',6X,'PERTURBED VALUE',3X,'DIFFERENCE',   &
        3X,'PERTURB DIRECTION',/,   &
        1X,A,2X,G12.5,4X,G12.5,4X,G12.5,2X,G12.5,2X,A)
    !
    OKLOCAL = .TRUE.
    IFAIL = 0
    !
    !   First, populate PSETTMP with current parameter values
    DO I=1,NPE
      PSETTMP(I) = PVAL(IPTR(I))
    ENDDO
    KPE = 0
    ! for debugging
!    write(gwmout,*)'at top of main_gen, current parameter values = '
!    write(gwmout,'(8g15.8)')(psettmp(i),i=1,npe)
    !
    K = 0
    PDIR: DO IP=1,NPE
      KINC = 1
      K = K+KINC
      IF (K.GE.KPPL) THEN
        KPE = IP
        EXIT PDIR
      ENDIF
    ENDDO PDIR
    PERTURBDIRECTION = 'FORWARD'
    PSIGN = 1.0D0
    PERTVAL = PVAL(IPTR(KPE)) + PSIGN*DELINC(KPE)
    PRECPR = 2
    CALL UTL_WRTSIG(IFAIL,PERTVAL,WORD,NW(IPTR(KPE)),PRECPR,   &
                    PSETTMP(KPE),NOPNT)
    IF (IFAIL .NE. 0) THEN
      OKLOCAL = .FALSE.
      GOTO 999
    ENDIF
  !
    IF (PERTURBDIRECTION=='FORWARD') PVALFWD(KPE) = PSETTMP(KPE)
    DELB(KPE) = PSETTMP(KPE) - PVAL(IPTR(KPE))
    !
    IF (IVERB .GE. 3) WRITE(IOUT,100)PARNAM(IPTR(KPE)),   &
        PVAL(IPTR(KPE)),PSETTMP(KPE),DELB(KPE),PERTURBDIRECTION
    !
    999 CONTINUE
    IF (OK) OK = OKLOCAL
    ! for debugging
!    write(gwmout,*)'at bottom of main_gen, perturbed values = '
!    write(gwmout,'(8g15.8)')(psettmp(i),i=1,npe)
    RETURN
  END SUBROUTINE MAIN_GEN
  !-----------------------------------------------------------------------------
  SUBROUTINE MAIN_UEV(NDEPSTAT,DEPVALS,IPERT,NHB,NDD,NDF,NGD,NSF,NSD,NFVAR, &
                      DEWATERQ,MFCNVRG,HCLOSEG,HDRY,GWMOUT,OK)
    ! Use extracted values to populate HDCSTATE array and other variables
    USE GWM1HDC3, ONLY: GWM1HDC3OS
    USE GWM1STC3, ONLY: GWM1STC3OS, STCNUM
    USE GWM1STA3, ONLY: GWM1STA3OS, STANUM, NHVAR, NRVAR, NSVAR, NDVAR, NSTADEP, &
                        SVILOC
    IMPLICIT NONE
    !   Argument-list variables
    INTEGER, INTENT(IN) :: NDEPSTAT
    DOUBLE PRECISION, DIMENSION(NDEPSTAT), INTENT(IN) :: DEPVALS
    INTEGER, INTENT(IN) :: IPERT
    INTEGER, INTENT(IN) :: NHB, NDD, NDF, NGD, NSF, NSD, NFVAR
    LOGICAL, INTENT(INOUT) :: DEWATERQ(-1:NFVAR+1), MFCNVRG(-1:NFVAR+1)
    REAL(DP), INTENT(INOUT) :: HCLOSEG
    REAL(DP), INTENT(IN) :: HDRY
    INTEGER, INTENT(IN) :: GWMOUT
    LOGICAL, INTENT(INOUT) :: OK
    !   Local variables
    INTEGER :: I, IC1, IDWSTAT, IHDRY, IMFSTAT, NHDC, NSLOC, NSTC
    LOGICAL :: OKLOCAL
    ! Format statements
    1000 FORMAT('GWM FINDS AT LEAST ONE DRY MANAGED-FLOW CELL')
    !
    OKLOCAL = .TRUE.
    NHDC = NHB+NDD+NDF*2+NGD*2
    NSTC = STCNUM
    !
    !   Populate HDCSTATE array
    !   First three arguments are not relevant to calls from GWM-VI
    IF (NHDC>0) CALL GWM1HDC3OS(1,1,IPERT,HDRY,NDEP,DEPVALS)
    IF (.NOT. OKLOCAL) GOTO 100
    !
    !   Populate STCSTATE array
    IC1 = NHDC+1
    IF (NSTC>0) THEN
    !   First two arguments are not relevant to calls from GWM-VI
      CALL GWM1STC3OS(1,1,IC1,NDEP,DEPVALS)
      IF (.NOT. OKLOCAL) GOTO 100
      IC1 = IC1+NSTC
    ENDIF
    !
    IF (STANUM>0) THEN
    !   First eleven arguments are not relevant to calls from GWM-VI
      CALL GWM1STA3OS(1,1,1,1,HDRY,1,1, &
                      1,1,1,1,IC1,NDEP,DEPVALS)
      IF (.NOT. OKLOCAL) GOTO 100
      IC1 = IC1 + NSTADEP        ! Add the number of dependents related to state variables
    ENDIF
    !
    !   Assign MFCNVRG, DEWATERQ, HCLOSE, and HNOFLO
    IMFSTAT = NINT(DEPVALS(IC1))
    IF (IMFSTAT==0) THEN
      MFCNVRG(IPERT) = .TRUE.
    ELSE
      MFCNVRG(IPERT) = .FALSE.
    ENDIF
    IC1 = IC1+1
    IDWSTAT = NINT(DEPVALS(IC1))
    IF (IDWSTAT==0) THEN
      DEWATERQ(IPERT) = .FALSE.
    ELSE
      DEWATERQ(IPERT) = .TRUE.
      WRITE(GWMOUT,1000)
    ENDIF
    !
    ! Error handling
    100 CONTINUE
    IF (OK) OK = OKLOCAL
    RETURN
  END SUBROUTINE MAIN_UEV
  !-----------------------------------------------------------------------------
  SUBROUTINE MAIN_CLN()
    !   Deallocate all arrays, linked lists, and CDMATRIX structures in the
    !   Main module
    USE UTILITIES
    USE DATATYPES
    IMPLICIT NONE
    IF (ALLOCATED(NW)) DEALLOCATE(NW)
    IF (ALLOCATED(PARNAM)) DEALLOCATE(PARNAM)
    IF (ALLOCATED(PARGP)) DEALLOCATE(PARGP)
    IF (ALLOCATED(PVAL)) DEALLOCATE(PVAL)
    IF (ALLOCATED(PVALTMP)) DEALLOCATE(PVALTMP)
    IF (ALLOCATED(PVALMIN)) DEALLOCATE(PVALMIN)
    IF (ALLOCATED(PVALMAX)) DEALLOCATE(PVALMAX)
    IF (ALLOCATED(PADJ)) DEALLOCATE(PADJ)
    IF (ALLOCATED(PASSIGNED)) DEALLOCATE(PASSIGNED)
    IF (ALLOCATED(IPTR)) DEALLOCATE(IPTR)
    IF (ALLOCATED(MODELVAL)) DEALLOCATE(MODELVAL)
    IF (ALLOCATED(TEMPVAL)) DEALLOCATE(TEMPVAL)
    IF (ALLOCATED(OBSNAM)) DEALLOCATE(OBSNAM)
    IF (ALLOCATED(WTVEC)) DEALLOCATE(WTVEC)
    IF (ALLOCATED(IPERTURBMETHOD)) DEALLOCATE(IPERTURBMETHOD)
    IF (ALLOCATED(PERTURBRAT)) DEALLOCATE(PERTURBRAT)
    IF (ALLOCATED(PERTURBMIN)) DEALLOCATE(PERTURBMIN)
    IF (ALLOCATED(BINC)) DEALLOCATE(BINC)
    IF (ALLOCATED(DNPP)) DEALLOCATE(DNPP)
    CALL TYP_DEALLOC(OPTHEAD)
    CALL TYP_DEALLOC(MCLHEAD)
    CALL TYP_DEALLOC(MIFHEAD)
    CALL TYP_DEALLOC(MOFHEAD)
    CALL TYP_DEALLOC(PLLHEAD)
    CALL TYP_DEALLOC(RUNHEAD)
    RETURN
  END SUBROUTINE MAIN_CLN
  !-----------------------------------------------------------------------------
  SUBROUTINE MAIN_WRITE_MF_STATUS_JIF()
    ! Write file modflow_status.jif to current directory
    USE UTILITIES, ONLY: UTL_GETUNIT
    IMPLICIT NONE
    ! Local variables
    INTEGER :: IU
    ! Format statements
    10 FORMAT('jif %                 MARKER-DELIMITER')
    20 FORMAT('StandardFile 0 3 2    NSKIP READCOLUMN NREAD')
    30 FORMAT('modflow_stat')
    40 FORMAT('dewater_stat')
    !
    IU = UTL_GETUNIT(7,10000)
    OPEN(IU,FILE='modflow_status.jif',STATUS='REPLACE')
    WRITE(IU,10)
    WRITE(IU,20)
    WRITE(IU,30)
    WRITE(IU,40)
    CLOSE(IU)
    !
    RETURN
  END SUBROUTINE MAIN_WRITE_MF_STATUS_JIF
  !-----------------------------------------------------------------------------
  SUBROUTINE MAIN_WRITE_MIF_BLOCK(IU,MNW2FILE)
    USE GWM1DCV3, ONLY: MNW2HERE
    IMPLICIT NONE
    ! Arguments
    INTEGER, INTENT(IN) :: IU
    CHARACTER(LEN=*), INTENT(IN) :: MNW2FILE
    ! Local variables
    INTEGER :: K
    ! Format statements
    10 FORMAT('BEGIN Model_Input_Files table')
    20 FORMAT('  nrow=',I1,' ncol=2 columnlabels')
    30 FORMAT('  ModInFile  TemplateFile')
    40 FORMAT('  mmproc.in  mmproc.in.jtf')
    41 FORMAT('  ',A,'  mnw2_input.jtf')
    50 FORMAT('END Model_Input_Files')
    !
    K = 1
    IF (MNW2HERE) K = K + 1
    WRITE(IU,10)
    WRITE(IU,20)K
    WRITE(IU,30)
    WRITE(IU,40)
    IF (MNW2HERE) WRITE(IU,41)TRIM(MNW2FILE)
    WRITE(IU,50)
    RETURN
  END SUBROUTINE MAIN_WRITE_MIF_BLOCK
  !-----------------------------------------------------------------------------
  SUBROUTINE MAIN_WRITE_MOF_BLOCK(IU)
    IMPLICIT NONE
    ! Arguments
    INTEGER, INTENT(IN) :: IU
    ! Format statements
    10 FORMAT('BEGIN Model_Output_Files table')
    20 FORMAT('  nrow=2 ncol=2 columnlabels')
    30 FORMAT('  ModOutFile           InstructionFile')
    40 FORMAT('  SimulatedValues.out  SimulatedValues.jif')
    50 FORMAT('  modflow.status       modflow_status.jif')
    60 FORMAT('END Model_Output_Files')
    WRITE(IU,10)
    WRITE(IU,20)
    WRITE(IU,30)
    WRITE(IU,40)
    WRITE(IU,50)
    WRITE(IU,60)
    RETURN
  END SUBROUTINE MAIN_WRITE_MOF_BLOCK
  !-----------------------------------------------------------------------------
  SUBROUTINE MAIN_WRITEEPARS(NPE)
    !   Print parameter-related data
    IMPLICIT NONE
    !
    !   Argument-list variables
    INTEGER, INTENT(IN) :: NPE
    !
    !   Local variables
    INTEGER :: I
    !
    200 FORMAT(/,   &
        1X,'Name',14X,'Value',7X,'Lower bound',  &
        4X,'Upper bound',3X,'Par. no.',/     &
        1X,12('-'),3(2X,13('-')),2X,8('-'))
    210 FORMAT(1X,A,3(2X,G13.6),2X,I6)
    !
    !   Write data for the set of parameters for which adjustable=yes
    WRITE(IOUTMESS,200)
    DO I=1,NPE
      WRITE(IOUTMESS,210)PARNAM(IPTR(I)),PVAL(IPTR(I)),    &
          PVALMIN(IPTR(I)),PVALMAX(IPTR(I)),IPTR(I) 
    ENDDO
    !
    RETURN
  END SUBROUTINE MAIN_WRITEEPARS
    !---------------------------------------------------------------------------
  SUBROUTINE MAIN_WRITEPARS(NPTC)
    !   Print parameter-related data
    IMPLICIT NONE
    !
    !   Argument-list variables
    INTEGER, INTENT(IN) :: NPTC
    !
    !   Local variables
    INTEGER :: I
    !
    !   Format statements
    200 FORMAT(/,   &
        1X,'Param. name ',6X,'Value',7X,'Lower bound',  &
        4X,'Upper bound',3X,'Adj.?',2X,'Assigned?',/,   &
        1X,12('-'),3(2x,13('-')),2X,5('-'),2X,9('-'))
    210 FORMAT(1X,A,3(2x,G13.6),4X,L1,8X,L1)
    !
    !   Write data for each parameter in the parameter set
    WRITE(IOUTMESS,200)
    DO I=1,NPTC
      WRITE(IOUTMESS,210)PARNAM(I),PVAL(I),PVALMIN(I),    &
          PVALMAX(I),PADJ(I),PASSIGNED(I)
    ENDDO
    !
    RETURN
  END SUBROUTINE MAIN_WRITEPARS
  !---------------------------------------------------------------------------
  SUBROUTINE DECVARS_TO_PVAL(NFVAR,NPT,FVARS,FVNCELL,PVAL)
    !   Populate PVAL array using values from FVARS array and FVRATIO
    USE GWM1DCV3, ONLY : GWM1DCV3FVCPNT,FVRATIO
    IMPLICIT NONE
    !   Argument-list variables
    INTEGER, INTENT(IN) :: NFVAR, NPT
    DOUBLE PRECISION, DIMENSION(NFVAR),       INTENT(IN)  :: FVARS
    INTEGER,          DIMENSION(NFVAR),       INTENT(IN)  :: FVNCELL
    DOUBLE PRECISION, DIMENSION(NPT),         INTENT(OUT) :: PVAL
    !   Local variables
    INTEGER :: I, IP, IPTRI, K, NC
    !
    IP = 0
    DO I=1,NFVAR
      NC = ABS(FVNCELL(I))
      IF (NC == 1) THEN
        IP = IP + 1
        PVAL(IP) = FVARS(I)
      ELSE
        CALL GWM1DCV3FVCPNT(I)  ! Point to correct arrays for FVRATIO
        ! TODO: Check this.  If MNW-based dec.vars. work like WEL-based dec.vars., 
        ! eliminate "IF (FVNCELL(I)>0)" condition.
        IF (FVNCELL(I)>0) THEN 
          ! Process non-distributed WEL-based decision variable
          IP = IP + 1
          PVAL(IP) = FVARS(I)
        ENDIF
        DO K=1,NC
          IP = IP + 1
          PVAL(IP) = FVARS(I)*FVRATIO(K)
        ENDDO
      ENDIF
    ENDDO
    !    
    RETURN
  END SUBROUTINE DECVARS_TO_PVAL
  !-----------------------------------------------------------------------------
END MODULE GWMMOD